# ecs

This is a generic entity-component-system framework I've been working on to support some side projects. I've been using it with [ebiten](https://github.com/hajimehoshi/ebiten), but there are no dependancies on any particular game engine.

This is pre-1.0 code, and I make no guarantees that the API won't change. Similarly, this code has not been optimized or even used in anything but trivially small projects so far, so don't be surprised when it performs badly and/or breaks on you.

There's a companion app called `ecsgen` (in the `cmd` folder) that creates all the plumbing behind Components for you, allowing the go code you write to be clear and concise. See the `test` folder for working examples.

## Install

- `go get github.com/danbrakeley/ecs`
- `go install github.com/danbrakeley/ecs/cmd/ecsgen`

## Quick Overview

I assume a base level of familiarity with ecs, which, if you don't have, is easy to obtain by searching the web for "entity component system".

To get started, you will need the following pieces:

1. A "Manager", which is created with `ecs.NewManager()`, and which provides:
   - A place to register your Systems, so that Entities know who to tell when they add/remove Components.
   - A "World", which is just a group of Entities and their Components.
   - A place to register your Components, in order to allow previously serialized Entities to be re-built (this is optional).
1. One or more "System", registered with your Manager.
   - Just create a type that impliments the [System interface](system.go).
   - Systems use `UpdateEntity` to see if a given Entity has any Components that the System cares about.
     - If so, Systems often will track that Entity by adding it to a map or slice.
     - `UpdateEntity` is also called when an Entity has removed a Component, so a System must stop tracking a previously tracked Entity in that case.
   - Similarly, Systems use `DropEntity` to know when an Entity is about to be destroyed.
1. One or more "Component", optionally registered with your Manager.
   - It is highly recommended to use `go generate` with the `ecsgen` app in order to build type-safe boilerplate for your Components.
   - The ecs package provides a singleton registry for all Components. Any `ecsgen` Components will automatically register themselves in a generated `init()` call.
   - It is optional, but if you provide Serialize/Deserialize funcs, then you can save off your Entities, and restore them later.
     - Serialization can be useful for saving game state, creating an undo buffer, or even building static assets that are loaded when the game starts up.

## Ticks

Since Components are just dumb stores of data, they do not get updates or ticks. In an ecs framework, it is the Systems that have the logic, so it is the Systems that get Ticks. If you call `Tick` on your Manager, it will call `Tick` on each registered System that implements the `Ticker` interface. The System should then iterate over all the Entities that it is tracking.

## Messages

You can call `Broadcast` on your Manager, passing it an Entity, and that Entity will be passed to all Systems that implement the `Receiver` interface. The Systems that receive the Entity should then look on that Entity for Components that convey the message itself.

For example, if you had this Component:

```go
package messages

type Action byte

const (
  ActionJump Action = iota
  ActionGetBored
  ActionGoOnAWalkabout
)

type ActionMsg struct {
  ecs.ComponentBase
  Action Action
}

//...
```

Then you could have a Player System that listens like this:

```go
package systems

//...

func (s *PlayerSys) HandleBroadcast(msgEntity *ecs.Entity) {
  actionMsg := messages.GetActionMsg(msgEntity)
  if actionMsg == nil {
    return
  }
  switch actionMsg.Action {
  case ActionJump: //...
  case ActionGetBored: //...
  case ActionGoOnAWalkabout: //...
  }
}
```

I've used the same Entity that has the message Component on it to also have an Input Component that the InputSystem uses to handle input. So if the input matches a particular Input Component, then that Component's Entity is Broadcast, and I know the Player System will hear it and be able to understand it, because that same Entity also has an ActionMsg Component on it.

## Components referencing another Entity's Components

There are reference types generated by `ecsgen` that can handle inter-Entity referencing. These are safe to serialize/deserialize. The reference is just the unique ID of the Entity that owns the referenced Component, and is resolved at runtime.
