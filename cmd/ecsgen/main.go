package main

import (
	"flag"
	"fmt"
	"html/template"
	"os"
	"path"
	"strings"
)

const (
	version         = "0.4.0"
	templatedOutput = `package {{.Package}}

import (
	"bytes"
	"fmt"

	"github.com/danbrakeley/ecs"
)

//   ___  ___ ___  __ _  ___ _ __
//  / _ \/ __/ __|/ _{{.Backtick}} |/ _ \ '_ \
// |  __/ (__\__ \ (_| |  __/ | | |
//  \___|\___|___/\__, |\___|_| |_|  v{{.Version}}
//                |___/
//
// WARNING: This file was generated by ecsgen.
// Any changes made to this file by hand may be lost.
//

func init() {
{{range .Components}}	ecs.RegisterComponent({{.ComNameVarName}}, Deserialize{{.TypeName}})
{{end}}}
{{range .Components}}
//
// *** {{.TypeName}} ***

// {{.ComNameVarName}} is {{.TypeName}}'s ComponentName
const {{.ComNameVarName}} ecs.ComponentName = "{{.ComNameLiteral}}"

// Get{{.TypeName}} returns any {{.TypeName}} on the given Entity
func Get{{.TypeName}}(e *ecs.Entity) *{{.TypeName}} {
	if c := e.GetComponent({{.ComNameVarName}}); c != nil {
		return c.(*{{.TypeName}})
	}
	return nil
}

// GetName is from the Component interface
func (c *{{.TypeName}}) GetName() ecs.ComponentName {
	return {{.ComNameVarName}}
}
{{if (eq .HasSerializer false)}}
// Serialize writes this {{.TypeName}} to the given buffer
func (c *{{.TypeName}}) Serialize(buf *bytes.Buffer) error {
	return ecs.SerializeToJSON(buf, c)
}
{{end}}{{if (eq .HasDeserializer false)}}
// Deserialize{{.TypeName}} creates a {{.TypeName}} from the given buffer
func Deserialize{{.TypeName}}(mgr *ecs.Manager, e *ecs.Entity, buf *bytes.Buffer) error {
	return fmt.Errorf("Deserialize{{.TypeName}} not implemented")
}
{{end}}
//
// {{.TypeName}}Ref is a {{.TypeName}} reference that can be serialized
type {{.TypeName}}Ref struct {
	mgr      *ecs.Manager
	parentID string
}

// New{{.TypeName}}Ref constructs a {{.TypeName}}Ref
func New{{.TypeName}}Ref(c *{{.TypeName}}) {{.TypeName}}Ref {
	var r {{.TypeName}}Ref
	r.Set(c)
	return r
}

// Set updates this reference to point to the given component (or nil)
func (r *{{.TypeName}}Ref) Set(c *{{.TypeName}}) {
	if c == nil {
		r.mgr = nil
		r.parentID = ""
		return
	}
	r.mgr = c.GetManager()
	r.parentID = c.GetEntityID()
}

// IsNil checks if the component pointer == nil
func (r {{.TypeName}}Ref) IsNil() bool {
	return len(r.parentID) == 0
}

// Get resolves this reference to a {{.TypeName}} pointer
func (r {{.TypeName}}Ref) Get() *{{.TypeName}} {
	if r.IsNil() {
		return nil
	}
	return Get{{.TypeName}}(r.mgr.GetEntity(r.parentID))
}

// GetEntity resolves the Entity owning the referenced component
func (r {{.TypeName}}Ref) GetEntity() *ecs.Entity {
	if r.IsNil() {
		return nil
	}
	return r.mgr.GetEntity(r.parentID)
}

// Serialize just writes out the parent entity id
func (r {{.TypeName}}Ref) Serialize(buf *bytes.Buffer) error {
	if r.IsNil() {
		buf.WriteString("null")
		return nil
	}
	buf.WriteString(fmt.Sprintf("\"%s\"", r.parentID))
	return nil
}
{{end}}`
)

// getOutputFileName returns a string in the form: <base>_ecs[_test].ext
func getOutputFileName(inFile string) string {
	ext := path.Ext(inFile)
	base := strings.TrimSuffix(inFile, ext)
	var genFmt string
	if strings.HasSuffix(base, "_test") {
		base = strings.TrimSuffix(base, "_test")
		genFmt = "%s_ecs_test%s"
	} else {
		genFmt = "%s_ecs%s"
	}
	return fmt.Sprintf(genFmt, base, ext)
}

// Vars are the dynamic fields that are needed to generate a component _gen.go file
type Vars struct {
	Backtick   string // a string containing a single backtick (`)
	Version    string
	Package    string
	File       string
	GenFile    string
	Components []Component
}

// Component is the component name and line upon which it was found
type Component struct {
	Line            int
	TypeName        string
	ComNameLiteral  string
	ComNameVarName  string
	HasSerializer   bool
	HasDeserializer bool
}

func main() {
	var vars Vars
	flag.StringVar(&vars.Package, "package", "", "the package where this component will live")
	flag.StringVar(&vars.File, "file", "", "the source file that contains the '//go:generate escgen ...'")
	flag.Parse()

	fmt.Printf("ecsgen v%s: package=\"%s\", file=\"%s\"\n", version, vars.Package, vars.File)

	if len(vars.Package) == 0 || len(vars.File) == 0 {
		fmt.Printf("missing parameter(s)\n")
		os.Exit(-1)
	}

	// we know some of the template vars already
	vars.Backtick = "`"
	vars.Version = version

	{
		// open the source go file to retreive the componant type name
		f, err := os.Open(vars.File)
		if err != nil {
			panic(err)
		}
		defer f.Close()

		vars.Components = getComponents(f)
		if len(vars.Components) == 0 {
			panic(fmt.Errorf("No components found in file %s", vars.File))
		}
	}

	// generate full component names
	for i := range vars.Components {
		vars.Components[i].ComNameLiteral = strings.Title(vars.Package) + vars.Components[i].TypeName
		vars.Components[i].ComNameVarName = vars.Components[i].TypeName + "Name"
	}

	// make generated file name
	vars.GenFile = getOutputFileName(vars.File)

	// now generate the output from the template
	tmpl, err := template.New("component").Parse(templatedOutput)
	if err != nil {
		panic(err)
	}
	f, err := os.Create(vars.GenFile)
	if err != nil {
		panic(err)
	}
	err = tmpl.Execute(f, vars)
	if err != nil {
		panic(err)
	}
}
